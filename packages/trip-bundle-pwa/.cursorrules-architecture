# Trip Bundle PWA - Architecture Rules

## ðŸ“ Directory Structure

```
src/
â”œâ”€â”€ components/     # React components (UI only)
â”œâ”€â”€ store/         # MobX stores (application state)
â”œâ”€â”€ actions/       # Actions (business logic)
â”œâ”€â”€ storage/       # Local storage utilities
â””â”€â”€ types.ts       # TypeScript type definitions
```

## ðŸ—ï¸ Architecture Pattern

### **CRITICAL RULE: Actions-Only Data Flow**
**ALL data operations MUST go through action functions. Never directly call storage or service functions from components.**

```typescript
// âœ… CORRECT - Components call actions only
const handleSave = () => {
  updatePreferences(preferences, dateRange, isMock);
};

// âŒ WRONG - Components never call storage/service directly
const handleSave = () => {
  saveUserPreferences(preferences);
  const response = await generateTripBundles(userData);
};
```

### **Data Flow Pattern**
1. **Components** â†’ Call **Actions**
2. **Actions** â†’ Read from **Storage** and call **Services**
3. **Actions** â†’ Update **Store** with results
4. **Store** â†’ Triggers component re-renders (MobX observer)

## ðŸ”„ Layer Responsibilities

### **Components Layer**
- Render UI elements
- Handle user interactions
- Call action functions
- Observe store state (MobX observer)
- **NEVER** directly access storage or services

### **Actions Layer** 
- Business logic and data orchestration
- Read from storage utilities
- Call external services (trip-bundle-prompts-service)
- Update MobX store with results
- Handle error states and loading

### **Store Layer (MobX)**
- Application state management
- Observable state for components
- Computed values and getters
- State mutations (called by actions)

### **Storage Layer**
- localStorage utilities
- Data persistence
- Default value providers
- **ONLY** called by actions, never by components

## ðŸŽ¯ Action Function Patterns

### **Action Function Template**
```typescript
export const actionName = async (params: Type) => {
  console.log('ðŸŽ¯ Starting action...', params);
  
  // 1. Update loading state
  appStore.setLoading(true);
  
  try {
    // 2. Read from storage if needed
    const data = getFromStorage();
    
    // 3. Call service if needed
    const result = await serviceCall(data);
    
    // 4. Save to storage if needed
    saveToStorage(result);
    
    // 5. Update store
    appStore.updateState(result);
    
    console.log('âœ… Action completed', result);
  } catch (error) {
    console.error('âŒ Action failed:', error);
    // Handle error state
  } finally {
    appStore.setLoading(false);
  }
};
```

## ðŸ“‹ Implementation Checklist

- [ ] Component only calls actions, never storage/services
- [ ] Action handles all business logic
- [ ] Store is updated through actions only
- [ ] Loading states managed in actions
- [ ] Error handling in actions
- [ ] Console logging for debugging
- [ ] TypeScript types for all parameters

## ðŸš« Anti-Patterns to Avoid

```typescript
// âŒ Component directly calling storage
const preferences = getUserPreferences();

// âŒ Component directly calling service
const bundles = await generateTripBundles(userData);

// âŒ Component directly updating store
appStore.setBundles(bundles);

// âŒ Mixing concerns in one function
const handleSave = () => {
  // Don't mix UI logic with data logic
  setLoading(true);
  saveData();
  updateStore();
  setLoading(false);
};
```

## âœ… Correct Patterns

```typescript
// âœ… Component calls action
const handleSave = () => {
  updatePreferences(preferences, dateRange, isMock);
};

// âœ… Action orchestrates everything
export const updatePreferences = async (prefs, dates, mock) => {
  appStore.setLoading(true);
  try {
    saveUserPreferences(prefs);
    const result = await generateTripBundles(userData, mock);
    appStore.setBundles(result.bundles);
  } finally {
    appStore.setLoading(false);
  }
};
```

This architecture ensures:
- Clear separation of concerns
- Predictable data flow
- Easy testing and debugging
- Consistent error handling
- Maintainable codebase
